<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Askrypt Vault Decryptor (read-only)</title>
        <!--TODO: embed jszip and crypto-js into this file-->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.2.0/crypto-js.min.js"></script>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family:
                    -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                    "Helvetica Neue", Arial, sans-serif;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                min-height: 100vh;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            }

            .container {
                background: white;
                border-radius: 12px;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
                width: 100%;
                max-width: 600px;
                padding: 40px;
            }

            h1 {
                color: #333;
                margin-bottom: 10px;
                font-size: 28px;
            }

            .subtitle {
                color: #666;
                margin-bottom: 30px;
                font-size: 14px;
            }

            .form-group {
                margin-bottom: 25px;
            }

            label {
                display: block;
                margin-bottom: 8px;
                color: #333;
                font-weight: 500;
                font-size: 14px;
            }

            input[type="file"],
            input[type="text"],
            input[type="password"],
            textarea {
                width: 100%;
                padding: 12px;
                border: 2px solid #e0e0e0;
                border-radius: 6px;
                font-size: 14px;
                transition: border-color 0.3s;
            }

            input[type="file"] {
                padding: 8px;
            }

            input[type="password"]:focus,
            textarea:focus {
                outline: none;
                border-color: #667eea;
                background-color: #f8f9ff;
            }

            .questions-container {
                background: #f5f5f5;
                padding: 20px;
                border-radius: 8px;
                display: none;
            }

            .question-input {
                margin-bottom: 15px;
            }

            .question-input label {
                margin-bottom: 6px;
            }

            .question-input input {
                width: 100%;
            }

            button {
                width: 100%;
                padding: 12px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                border: none;
                border-radius: 6px;
                font-size: 16px;
                font-weight: 600;
                cursor: pointer;
                transition:
                    transform 0.2s,
                    box-shadow 0.2s;
                margin-bottom: 10px;
            }

            button:hover {
                transform: translateY(-2px);
                box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
            }

            button:active {
                transform: translateY(0);
            }

            button:disabled {
                opacity: 0.6;
                cursor: not-allowed;
            }

            .secondary-btn {
                background: #e0e0e0;
                color: #333;
                margin-bottom: 0;
            }

            .secondary-btn:hover {
                background: #d0d0d0;
                box-shadow: none;
            }

            .results {
                background: #f5f5f5;
                padding: 20px;
                border-radius: 8px;
                margin-top: 20px;
                display: none;
            }

            .results.show {
                display: block;
            }

            .results h3 {
                color: #333;
                margin-bottom: 15px;
                font-size: 18px;
            }

            .secret-entry {
                background: white;
                padding: 15px;
                border-radius: 6px;
                margin-bottom: 15px;
                border-left: 4px solid #667eea;
            }

            .secret-entry h4 {
                color: #333;
                margin-bottom: 10px;
                font-size: 16px;
            }

            .secret-field {
                margin-bottom: 8px;
                font-size: 14px;
            }

            .secret-field-label {
                font-weight: 600;
                color: #666;
            }

            .secret-field-value {
                color: #333;
                word-break: break-all;
                font-family: "Courier New", monospace;
                background: #f9f9f9;
                padding: 6px;
                border-radius: 4px;
                margin-top: 4px;
            }

            .error {
                background: #fee;
                border: 2px solid #f00;
                color: #c00;
                padding: 15px;
                border-radius: 6px;
                margin-bottom: 20px;
                display: none;
            }

            .error.show {
                display: block;
            }

            .success {
                background: #efe;
                border: 2px solid #0f0;
                color: #060;
                padding: 15px;
                border-radius: 6px;
                margin-bottom: 20px;
                display: none;
            }

            .success.show {
                display: block;
            }

            .loading {
                display: none;
                text-align: center;
                padding: 20px;
            }

            .loading.show {
                display: block;
            }

            .spinner {
                border: 4px solid #f3f3f3;
                border-top: 4px solid #667eea;
                border-radius: 50%;
                width: 40px;
                height: 40px;
                animation: spin 1s linear infinite;
                margin: 0 auto 10px;
            }

            @keyframes spin {
                0% {
                    transform: rotate(0deg);
                }
                100% {
                    transform: rotate(360deg);
                }
            }

            .info-box {
                background: #e8f4f8;
                border-left: 4px solid #00a8cc;
                padding: 15px;
                border-radius: 6px;
                margin-bottom: 20px;
                color: #003d5c;
                font-size: 13px;
                line-height: 1.5;
            }

            .tabs {
                display: flex;
                gap: 10px;
                margin-bottom: 15px;
                border-bottom: 2px solid #e0e0e0;
            }

            .tab-button {
                padding: 10px 15px;
                border: none;
                background: transparent;
                cursor: pointer;
                color: #666;
                font-weight: 500;
                border-bottom: 3px solid transparent;
                transition: all 0.3s;
                width: auto;
            }

            .tab-button.active {
                color: #667eea;
                border-bottom-color: #667eea;
            }

            .tab-content {
                display: none;
            }

            .tab-content.active {
                display: block;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>üîê Askrypt Vault Decryptor</h1>
            <p class="subtitle">Securely decrypt your Askrypt password vault</p>

            <div class="info-box">
                üí° All decryption happens in your browser. Your passwords never
                leave your computer.
            </div>

            <div class="error" id="error"></div>
            <div class="success" id="success"></div>
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>Decrypting...</p>
            </div>

            <form id="decryptForm">
                <div class="form-group">
                    <label for="fileInput">1. Select Askrypt or ZIP File</label>
                    <input type="file" id="fileInput" accept=".*" required />
                </div>

                <div class="form-group">
                    <label for="firstAnswer"
                        >2. Answer the First Security Question</label
                    >
                    <input
                        type="password"
                        id="firstAnswer"
                        placeholder="Your answer..."
                        required
                    />
                    <small
                        style="color: #999; display: block; margin-top: 5px"
                        id="question0Display"
                    ></small>
                </div>

                <div class="questions-container" id="questionsContainer">
                    <div id="questionsInputs"></div>
                </div>

                <button type="submit" id="decryptBtn">Decrypt Vault</button>
                <button type="button" class="secondary-btn" id="resetBtn">
                    Reset
                </button>
            </form>

            <div class="results" id="results">
                <div class="tabs">
                    <button
                        type="button"
                        class="tab-button active"
                        data-tab="entries"
                    >
                        Secrets
                    </button>
                    <button type="button" class="tab-button" data-tab="json">
                        JSON
                    </button>
                </div>

                <div id="entries" class="tab-content active"></div>
                <div id="json" class="tab-content">
                    <textarea
                        id="jsonOutput"
                        readonly
                        style="
                            min-height: 400px;
                            font-family: &quot;Courier New&quot;, monospace;
                            font-size: 12px;
                        "
                    ></textarea>
                </div>
            </div>
        </div>

        <script>
            class AskryptDecryptor {
                constructor() {
                    this.vaultData = null;
                    this.questionsData = null;
                    this.secretEntries = null;
                }

                /**
                 * Normalize an answer by removing whitespace and converting to lowercase
                 */
                normalizeAnswer(answer) {
                    return answer
                        .split("")
                        .filter((c) => !/\s|-|‚Äì|‚Äî/.test(c))
                        .join("")
                        .toLowerCase();
                }

                /**
                 * Hash a normalized data using SHA256 with salt
                 * Implements: askrypt::sha256(data, salt) from lib.rs
                 * Note: salt should be base64-encoded string, not raw bytes
                 */
                sha256WithSalt(data, salt) {
                    // salt can be passed as either base64 string or bytes
                    let saltStr = salt;
                    if (salt instanceof Uint8Array) {
                        saltStr = this.bytesToBase64(salt);
                    }
                    const combined = data + saltStr;
                    return CryptoJS.SHA256(combined).toString();
                }

                /**
                 * Decode base64 string to bytes
                 */
                base64ToBytes(base64) {
                    const binaryString = atob(base64);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    return bytes;
                }

                /**
                 * Encode bytes to base64 string
                 */
                bytesToBase64(bytes) {
                    let binary = "";
                    for (let i = 0; i < bytes.byteLength; i++) {
                        binary += String.fromCharCode(bytes[i]);
                    }
                    return btoa(binary);
                }

                /**
                 * Derive key using PBKDF2
                 */
                async derivePBKDF2(secret, salt, iterations) {
                    const encoder = new TextEncoder();
                    const secretKey = await crypto.subtle.importKey(
                        "raw",
                        encoder.encode(secret),
                        "PBKDF2",
                        false,
                        ["deriveBits"],
                    );

                    const derivedBits = await crypto.subtle.deriveBits(
                        {
                            name: "PBKDF2",
                            hash: "SHA-256",
                            salt: salt,
                            iterations: iterations,
                        },
                        secretKey,
                        256,
                    );

                    return new Uint8Array(derivedBits);
                }

                /**
                 * Decrypt AES-256-CBC encrypted data
                 */
                async decryptAES256CBC(ciphertext, key, iv) {
                    const cryptoKey = await crypto.subtle.importKey(
                        "raw",
                        key,
                        { name: "AES-CBC" },
                        false,
                        ["decrypt"],
                    );

                    const decrypted = await crypto.subtle.decrypt(
                        { name: "AES-CBC", iv: iv },
                        cryptoKey,
                        ciphertext,
                    );

                    return new Uint8Array(decrypted);
                }

                /**
                 * Remove PKCS7 padding
                 */
                removePKCS7Padding(data) {
                    const paddingLength = data[data.length - 1];
                    if (paddingLength > 0 && paddingLength <= 16) {
                        return data.slice(0, data.length - paddingLength);
                    }
                    return data;
                }

                /**
                 * Decrypt and deserialize base64-encoded encrypted data
                 */
                async decryptFromBase64(base64Data, key, iv) {
                    const encrypted = this.base64ToBytes(base64Data);
                    const decrypted = await this.decryptAES256CBC(
                        encrypted,
                        key,
                        iv,
                    );
                    const unpadded = this.removePKCS7Padding(decrypted);
                    const decoder = new TextDecoder();
                    const json = decoder.decode(unpadded);
                    return JSON.parse(json);
                }

                /**
                 * Load and parse the Askrypt JSON file or ZIP file
                 */
                async loadVault(file) {
                    return new Promise(async (resolve, reject) => {
                        try {
                            // Check if file is a zip
                            const fileName = file.name.toLowerCase();

                            if (
                                fileName.endsWith(".zip") ||
                                fileName.endsWith(".askrypt")
                            ) {
                                // Handle zip file
                                const zip = new JSZip();
                                const arrayBuffer = await file.arrayBuffer();
                                const loadedZip =
                                    await zip.loadAsync(arrayBuffer);

                                // Find the first JSON file in the zip
                                let jsonContent = null;
                                let foundFile = null;

                                for (const [
                                    filename,
                                    fileObj,
                                ] of Object.entries(loadedZip.files)) {
                                    if (
                                        filename
                                            .toLowerCase()
                                            .endsWith(".json") &&
                                        !fileObj.dir
                                    ) {
                                        jsonContent =
                                            await fileObj.async("string");
                                        foundFile = filename;
                                        break;
                                    }
                                }

                                if (!jsonContent) {
                                    reject(
                                        new Error(
                                            "No Askrypt file found in the ZIP archive",
                                        ),
                                    );
                                    return;
                                }

                                try {
                                    this.vaultData = JSON.parse(jsonContent);
                                    resolve();
                                } catch (err) {
                                    reject(
                                        new Error(
                                            `Invalid JSON file format in "${foundFile}": ${err.message}`,
                                        ),
                                    );
                                }
                            } else {
                                // Handle plain JSON file
                                const reader = new FileReader();
                                reader.onload = (e) => {
                                    try {
                                        this.vaultData = JSON.parse(
                                            e.target.result,
                                        );
                                        resolve();
                                    } catch (err) {
                                        reject(
                                            new Error(
                                                "Invalid JSON file format",
                                            ),
                                        );
                                    }
                                };
                                reader.onerror = () =>
                                    reject(new Error("Failed to read file"));
                                reader.readAsText(file);
                            }
                        } catch (err) {
                            reject(
                                new Error(
                                    `Failed to load vault: ${err.message}`,
                                ),
                            );
                        }
                    });
                }

                /**
                 * Get the questions from the vault using the first answer
                 * Implements: AskryptFile::get_questions_data
                 */
                async getQuestionsData(firstAnswer) {
                    if (!this.vaultData) {
                        throw new Error("Vault not loaded");
                    }

                    try {
                        // Decode salt0
                        const salt0 = this.base64ToBytes(
                            this.vaultData.params.salt,
                        );
                        const salt0_b64 = this.vaultData.params.salt; // Base64-encoded salt0
                        const salt0Iv = salt0;

                        // Hash first answer with base64-encoded salt0 and derive first key
                        const hashedAnswer = this.sha256WithSalt(
                            this.normalizeAnswer(firstAnswer),
                            salt0_b64,
                        );
                        const firstKey = await this.derivePBKDF2(
                            hashedAnswer,
                            salt0Iv,
                            this.vaultData.params.iterations,
                        );

                        // Decrypt questions data
                        this.questionsData = await this.decryptFromBase64(
                            this.vaultData.qs,
                            firstKey,
                            salt0Iv,
                        );

                        return this.questionsData;
                    } catch (err) {
                        throw new Error(
                            `Failed to get questions: ${err.message}`,
                        );
                    }
                }

                /**
                 * Decrypt the vault using the provided answers
                 * Implements: AskryptFile::decrypt
                 */
                async decrypt(answers) {
                    if (!this.questionsData) {
                        throw new Error("Questions data not loaded");
                    }

                    try {
                        if (answers.length < 1) {
                            throw new Error("At least 1 answer is required");
                        }

                        if (
                            this.questionsData.questions.length !==
                            answers.length
                        ) {
                            throw new Error(
                                "Number of questions and answers must match",
                            );
                        }

                        // Decode salt1
                        const salt1 = this.base64ToBytes(
                            this.questionsData.salt,
                        );
                        const salt1Iv = salt1;

                        // Get base64-encoded salt0 for hashing
                        const salt0_b64 = this.vaultData.params.salt;

                        // Normalize answers
                        const normalizedAnswers = answers.map((a) =>
                            this.normalizeAnswer(a),
                        );

                        // Combine hashed answers and derive second key
                        const combinedAnswers = normalizedAnswers.join("");
                        const secondKey = await this.derivePBKDF2(
                            this.sha256WithSalt(combinedAnswers, salt0_b64),
                            salt1Iv,
                            this.vaultData.params.iterations,
                        );

                        // Decrypt master key and IV
                        const masterData = await this.decryptFromBase64(
                            this.vaultData.master,
                            secondKey,
                            salt1Iv,
                        );

                        // Decode master key and IV
                        const masterKey = this.base64ToBytes(
                            masterData.masterKey,
                        );
                        const masterIv = this.base64ToBytes(masterData.iv);

                        // Decrypt secret data using master key and IV
                        this.secretEntries = await this.decryptFromBase64(
                            this.vaultData.data,
                            masterKey,
                            masterIv,
                        );

                        return this.secretEntries;
                    } catch (err) {
                        throw new Error(`Decryption failed: ${err.message}`);
                    }
                }
            }

            // UI Controller
            const decryptor = new AskryptDecryptor();
            const fileInput = document.getElementById("fileInput");
            const firstAnswerInput = document.getElementById("firstAnswer");
            const questionsContainer =
                document.getElementById("questionsContainer");
            const questionsInputs = document.getElementById("questionsInputs");
            const decryptBtn = document.getElementById("decryptBtn");
            const resetBtn = document.getElementById("resetBtn");
            const errorDiv = document.getElementById("error");
            const successDiv = document.getElementById("success");
            const loadingDiv = document.getElementById("loading");
            const resultsDiv = document.getElementById("results");
            const question0Display =
                document.getElementById("question0Display");

            function showError(message) {
                errorDiv.textContent = message;
                errorDiv.classList.add("show");
                successDiv.classList.remove("show");
            }

            function showSuccess(message) {
                successDiv.textContent = message;
                successDiv.classList.add("show");
                errorDiv.classList.remove("show");
            }

            function showLoading(show) {
                if (show) {
                    loadingDiv.classList.add("show");
                } else {
                    loadingDiv.classList.remove("show");
                }
            }

            fileInput.addEventListener("change", async (e) => {
                errorDiv.classList.remove("show");
                questionsContainer.style.display = "none";
                questionsInputs.innerHTML = "";

                if (!fileInput.files[0]) return;

                showLoading(true);
                try {
                    await decryptor.loadVault(fileInput.files[0]);
                    question0Display.textContent = `Question: ${decryptor.vaultData.question0}`;
                    showSuccess("Vault loaded successfully");
                } catch (err) {
                    showError(`Error loading vault: ${err.message}`);
                } finally {
                    showLoading(false);
                }
            });

            firstAnswerInput.addEventListener("blur", async () => {
                if (!firstAnswerInput.value || !decryptor.vaultData) return;

                showLoading(true);
                try {
                    await decryptor.getQuestionsData(firstAnswerInput.value);

                    // Display additional questions
                    questionsInputs.innerHTML = "";
                    decryptor.questionsData.questions.forEach(
                        (question, index) => {
                            const div = document.createElement("div");
                            div.className = "question-input";
                            div.innerHTML = `
                        <label for="answer${index}">Question ${index + 2}: ${question}</label>
                        <input type="password" id="answer${index}" placeholder="Your answer..." required>
                    `;
                            questionsInputs.appendChild(div);
                        },
                    );

                    questionsContainer.style.display = "block";
                    showSuccess("Questions loaded successfully");
                } catch (err) {
                    showError(`Error loading questions: ${err.message}`);
                    questionsContainer.style.display = "none";
                } finally {
                    showLoading(false);
                }
            });

            document
                .getElementById("decryptForm")
                .addEventListener("submit", async (e) => {
                    e.preventDefault();
                    errorDiv.classList.remove("show");

                    if (!firstAnswerInput.value) {
                        showError("Please answer the first question");
                        return;
                    }

                    const additionalAnswers = [];
                    document
                        .querySelectorAll("#questionsInputs input")
                        .forEach((input) => {
                            if (!input.value) {
                                showError("Please answer all questions");
                                return;
                            }
                            additionalAnswers.push(input.value);
                        });

                    if (
                        additionalAnswers.length !==
                        decryptor.questionsData?.questions.length
                    ) {
                        return;
                    }

                    showLoading(true);
                    try {
                        const allAnswers = additionalAnswers;
                        const secrets = await decryptor.decrypt(allAnswers);

                        // Display results
                        displayResults(secrets);
                        showSuccess(
                            `Successfully decrypted ${secrets.length} secret(s)`,
                        );
                    } catch (err) {
                        showError(`Decryption failed: ${err.message}`);
                    } finally {
                        showLoading(false);
                    }
                });

            function displayResults(secrets) {
                const entriesDiv = document.getElementById("entries");
                entriesDiv.innerHTML = "";

                secrets.forEach((entry, index) => {
                    const div = document.createElement("div");
                    div.className = "secret-entry";
                    div.innerHTML = `
                    <h4>${index + 1}. ${entry.name}</h4>
                    <div class="secret-field">
                        <span class="secret-field-label">Type:</span>
                        <div class="secret-field-value">${entry.type}</div>
                    </div>
                    ${
                        entry.user_name
                            ? `
                    <div class="secret-field">
                        <span class="secret-field-label">Username:</span>
                        <div class="secret-field-value">${escapeHtml(entry.user_name)}</div>
                    </div>
                    `
                            : ""
                    }
                    ${
                        entry.secret
                            ? `
                    <div class="secret-field">
                        <span class="secret-field-label">Secret:</span>
                        <div class="secret-field-value">${escapeHtml(entry.secret)}</div>
                    </div>
                    `
                            : ""
                    }
                    ${
                        entry.url
                            ? `
                    <div class="secret-field">
                        <span class="secret-field-label">URL:</span>
                        <div class="secret-field-value"><a href="${entry.url}" target="_blank">${escapeHtml(entry.url)}</a></div>
                    </div>
                    `
                            : ""
                    }
                    ${
                        entry.notes
                            ? `
                    <div class="secret-field">
                        <span class="secret-field-label">Notes:</span>
                        <div class="secret-field-value">${escapeHtml(entry.notes)}</div>
                    </div>
                    `
                            : ""
                    }
                    ${
                        entry.tags && entry.tags.length
                            ? `
                    <div class="secret-field">
                        <span class="secret-field-label">Tags:</span>
                        <div class="secret-field-value">${entry.tags.join(", ")}</div>
                    </div>
                    `
                            : ""
                    }
                `;
                    entriesDiv.appendChild(div);
                });

                document.getElementById("jsonOutput").value = JSON.stringify(
                    secrets,
                    null,
                    2,
                );
                resultsDiv.classList.add("show");
            }

            function escapeHtml(text) {
                const div = document.createElement("div");
                div.textContent = text;
                return div.innerHTML;
            }

            // Tab switching
            document.querySelectorAll(".tab-button").forEach((btn) => {
                btn.addEventListener("click", (e) => {
                    const tabName = e.target.dataset.tab;
                    document
                        .querySelectorAll(".tab-button")
                        .forEach((b) => b.classList.remove("active"));
                    document
                        .querySelectorAll(".tab-content")
                        .forEach((c) => c.classList.remove("active"));
                    e.target.classList.add("active");
                    document.getElementById(tabName).classList.add("active");
                });
            });

            resetBtn.addEventListener("click", () => {
                fileInput.value = "";
                firstAnswerInput.value = "";
                questionsInputs.innerHTML = "";
                questionsContainer.style.display = "none";
                resultsDiv.classList.remove("show");
                errorDiv.classList.remove("show");
                successDiv.classList.remove("show");
                question0Display.textContent = "";
                decryptor.vaultData = null;
                decryptor.questionsData = null;
                decryptor.secretEntries = null;
            });
        </script>
    </body>
</html>
